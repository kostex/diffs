diff --git a/data/darktableconfig.xml.in b/data/darktableconfig.xml.in
index 2ed7c57c6..46cb3ad41 100644
--- a/data/darktableconfig.xml.in
+++ b/data/darktableconfig.xml.in
@@ -1,21 +1,28 @@
 <?xml version="1.0"?>
 <!DOCTYPE dtconfiglist SYSTEM "darktableconfig.dtd">
 <dtconfiglist>
-  <dtconfig>
+  <dtconfig prefs="gui" section="darkroom">
+    <name>ktx/delete_off_modules</name>
+    <type>bool</type>
+    <default>false</default>
+    <shortdescription>delete 'off' modules</shortdescription>
+    <longdescription>when compressing history delete 'off' modules as well</longdescription>
+  </dtconfig>
+  <dtconfig prefs="gui" section="darkroom">
     <name>bauhaus/scale</name>
     <type>float</type>
     <default>1.4</default>
     <shortdescription>widget scale</shortdescription>
     <longdescription>scaling factor for bauhaus widgets, will affect font size</longdescription>
   </dtconfig>
-  <dtconfig>
+  <dtconfig prefs="gui" section="darkroom">
     <name>database</name>
     <type>string</type>
     <default>library.db</default>
     <shortdescription>database location</shortdescription>
     <longdescription>filename relative to ~/.config/darktable or starting with a slash (needs a restart).</longdescription>
   </dtconfig>
-  <dtconfig prefs="gui">
+  <dtconfig prefs="gui" section="darkroom">
     <name>panel_width</name>
     <type>int</type>
     <default>350</default>
@@ -631,6 +638,13 @@
     <shortdescription>enable extended thumb overlay</shortdescription>
     <longdescription>if set to true, thumb overlay shows filename and some exif data.</longdescription>
   </dtconfig>
+  <dtconfig prefs="gui" section="lighttable">
+    <name>ktx/show_exif_on_all_thumbs</name>
+    <type>bool</type>
+    <default>false</default>
+    <shortdescription>show exif overlay on all thumbnails</shortdescription>
+    <longdescription>when enabling 'extended thumb overlay', show them on all thumbs, not only the selected one</longdescription>
+  </dtconfig>
   <dtconfig prefs="gui" section="darkroom">
     <name>pressure_sensitivity</name>
     <type>
diff --git a/data/themes/darktable.css b/data/themes/darktable.css
index 7104f4da0..09f132c17 100644
--- a/data/themes/darktable.css
+++ b/data/themes/darktable.css
@@ -130,18 +130,19 @@
 @define-color brush_trace alpha(black, .8);
 
 /* Lighttable and film-strip */
-@define-color thumbnail_font_color @grey_50;
-@define-color thumbnail_bg_color @grey_40; /* area between border and outline */
-@define-color thumbnail_outline_color @grey_50; /* square around image+metadata */
-@define-color thumbnail_selected_font_color @grey_50;
-@define-color thumbnail_selected_bg_color @grey_60;
-@define-color thumbnail_selected_outline_color @grey_50;
-@define-color thumbnail_hover_font_color @grey_50;
-@define-color thumbnail_hover_bg_color @grey_80;
-@define-color thumbnail_hover_outline_color @grey_50;
+@define-color thumbnail_font_color #666666;
+@define-color thumbnail_bg_color @grey_45; /* area between border and outline */
+@define-color thumbnail_outline_color #fffae6; /* square around image+metadata */
+@define-color thumbnail_selected_font_color #666666;
+@define-color thumbnail_selected_bg_color #88bb00;
+@define-color thumbnail_selected_outline_color #88bb00;
+@define-color thumbnail_hover_font_color @grey_75;;
+@define-color thumbnail_hover_bg_color #ffd633;;
+@define-color thumbnail_hover_outline_color #fffae6;
 @define-color filmstrip_bg_color @darkroom_bg_color;
 @define-color culling_selected_border_color @grey_10;
 @define-color culling_filmstrip_selected_border_color @grey_10;
+@define-color ktx_1_color #1a1400;
 
 /* Graphs : histogram, navigation thumbnail and some items on tone curve */
 @define-color graph_bg @grey_10;
diff --git a/src/common/file_location.c b/src/common/file_location.c
index 69032ab46..96478da98 100644
--- a/src/common/file_location.c
+++ b/src/common/file_location.c
@@ -92,7 +92,7 @@ static gchar *dt_loc_init_generic(const char *value, const char *default_value)
 
 void dt_loc_init_user_config_dir(const char *configdir)
 {
-  char *default_config_dir = g_build_filename(g_get_user_config_dir(), "darktable", NULL);
+  char *default_config_dir = g_build_filename(g_get_user_config_dir(), "darktable_bld", NULL);
   darktable.configdir = dt_loc_init_generic(configdir, default_config_dir);
   g_free(default_config_dir);
 }
diff --git a/src/common/history.c b/src/common/history.c
index 3bb3c3524..e5fcd23d2 100644
--- a/src/common/history.c
+++ b/src/common/history.c
@@ -12,7 +12,6 @@
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
-
     You should have received a copy of the GNU General Public License
     along with darktable.  If not, see <http://www.gnu.org/licenses/>.
 */
@@ -952,6 +951,17 @@ void dt_history_compress_on_image(int32_t imgid)
   sqlite3_step(stmt);
   sqlite3_finalize(stmt);
 
+  if(dt_conf_get_bool("ktx/delete_off_modules"))
+  {
+    // remove disabled modules
+    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), "DELETE FROM main.history WHERE imgid = ?1 AND "
+                                                               "enabled = 0", -1, &stmt, NULL);
+    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);
+    sqlite3_step(stmt);
+    sqlite3_finalize(stmt);
+  }
+
+  // delete all mask_manager entries
   int masks_count = 0;
   char op_mask_manager[20] = { 0 };
 
diff --git a/src/common/mipmap_cache.c b/src/common/mipmap_cache.c
index e3c2c9a8a..b7ca9274c 100644
--- a/src/common/mipmap_cache.c
+++ b/src/common/mipmap_cache.c
@@ -118,11 +118,17 @@ static inline void dead_image_8(dt_mipmap_buffer_t *buf)
   dsc->iscale = 1.0f;
   dsc->color_space = DT_COLORSPACE_DISPLAY;
   assert(dsc->size > 64 * sizeof(uint32_t));
-  const uint32_t X = 0xffffffffu;
+  const uint32_t X = 0x33000040u;
   const uint32_t o = 0u;
   const uint32_t image[]
-      = { o, o, o, o, o, o, o, o, o, o, X, X, X, X, o, o, o, X, o, X, X, o, X, o, o, X, X, X, X, X, X, o,
-          o, o, X, o, o, X, o, o, o, o, o, o, o, o, o, o, o, o, X, X, X, X, o, o, o, o, o, o, o, o, o, o };
+      = { o, o, o, o, o, o, o, o,
+          o, X, o, o, o, o, X, o,
+          o, o, X, o, o, X, o, o,
+          o, o, o, X, X, o, o, o,
+          o, o, o, X, X, o, o, o,
+          o, o, X, o, o, X, o, o,
+          o, X, o, o, o, o, X, o,
+          o, o, o, o, o, o, o, o };
   memcpy(buf->buf, image, sizeof(uint32_t) * 64);
 }
 
diff --git a/src/dtgtk/paint.c b/src/dtgtk/paint.c
index e8c8fe552..8a45c7697 100644
--- a/src/dtgtk/paint.c
+++ b/src/dtgtk/paint.c
@@ -2055,6 +2055,23 @@ void dtgtk_cairo_paint_modulegroup_effect(cairo_t *cr, gint x, gint y, gint w, g
   cairo_stroke(cr);
 }
 
+void dtgtk_cairo_paint_modulegroup_all(cairo_t *cr, gint x, gint y, gint w, gint h, gint flags, void *data)
+{
+  gint s = w < h ? w : h;
+  cairo_translate(cr, x + (w / 2.) - (s / 2.), y + (h / 2.) - (s / 2.));
+  cairo_scale(cr, s, s);
+  cairo_set_line_cap(cr, CAIRO_LINE_CAP_ROUND);
+  cairo_set_line_width(cr, 0.1);
+
+  
+  cairo_move_to(cr, 0.2, 0.8);
+  cairo_line_to(cr, 0.5, 0.2);
+  cairo_line_to(cr, 0.8, 0.8);
+  cairo_move_to(cr, 0.3, 0.6);
+  cairo_line_to(cr, 0.7, 0.6);
+  cairo_stroke(cr);
+}
+
 void dtgtk_cairo_paint_map_pin(cairo_t *cr, gint x, gint y, gint w, gint h, gint flags, void *data)
 {
   const gint s = w < h ? w : h;
diff --git a/src/dtgtk/paint.h b/src/dtgtk/paint.h
index a5b99d27c..141db0520 100644
--- a/src/dtgtk/paint.h
+++ b/src/dtgtk/paint.h
@@ -174,6 +174,8 @@ void dtgtk_cairo_paint_modulegroup_color(cairo_t *cr, gint x, gint y, gint w, gi
 void dtgtk_cairo_paint_modulegroup_correct(cairo_t *cr, gint x, gint y, gint w, gint h, gint flags, void *data);
 /** paint effect modulegroup icon */
 void dtgtk_cairo_paint_modulegroup_effect(cairo_t *cr, gint x, gint y, gint w, gint h, gint flags, void *data);
+/** paint all modulegroup icon */
+void dtgtk_cairo_paint_modulegroup_all(cairo_t *cr, gint x, gint y, gint w, gint h, gint flags, void *data);
 
 /** paint the pin for map thumbnails */
 void dtgtk_cairo_paint_map_pin(cairo_t *cr, gint x, gint y, gint w, gint h, gint flags, void *data);
diff --git a/src/gui/gtk.c b/src/gui/gtk.c
index 3ad030e42..d59937ed3 100644
--- a/src/gui/gtk.c
+++ b/src/gui/gtk.c
@@ -2257,6 +2257,7 @@ void dt_gui_load_theme(const char *theme)
     [DT_GUI_COLOR_CULLING_FILMSTRIP_SELECTED_BORDER]
     = { "culling_filmstrip_selected_border_color", { 0.1, 0.1, 0.1, 1.0 } },
     [DT_GUI_COLOR_PREVIEW_HOVER_BORDER] = { "preview_hover_border_color", { 0.9, 0.9, 0.9, 1.0 } },
+    [DT_GUI_COLOR_KTX_1] = { "ktx_1_color", { 0.0, 0.0, 0.0, 1.0 } }
   };
 
   // starting from 1 as DT_GUI_COLOR_BG is not part of this table
diff --git a/src/gui/gtk.h b/src/gui/gtk.h
index c890ab4ba..b9efb3604 100644
--- a/src/gui/gtk.h
+++ b/src/gui/gtk.h
@@ -77,7 +77,8 @@ typedef enum dt_gui_color_t
   DT_GUI_COLOR_CULLING_SELECTED_BORDER,
   DT_GUI_COLOR_CULLING_FILMSTRIP_SELECTED_BORDER,
   DT_GUI_COLOR_PREVIEW_HOVER_BORDER,
-  DT_GUI_COLOR_LAST
+  DT_GUI_COLOR_KTX_1,
+  DT_GUI_COLOR_LAST,
 } dt_gui_color_t;
 
 typedef struct dt_gui_gtk_t
diff --git a/src/imageio/storage/CMakeLists.txt b/src/imageio/storage/CMakeLists.txt
index e5ed12de2..13243404b 100644
--- a/src/imageio/storage/CMakeLists.txt
+++ b/src/imageio/storage/CMakeLists.txt
@@ -7,9 +7,9 @@ add_definitions(-include imageio/storage/imageio_storage_api.h)
 
 set(MODULES disk email gallery latex)
 
-if(FLICKCURL_FOUND)
-	list(APPEND MODULES flickr)
-endif(FLICKCURL_FOUND)
+#if(FLICKCURL_FOUND)
+#	list(APPEND MODULES flickr)
+#endif(FLICKCURL_FOUND)
 
 if (JsonGlib_FOUND)
 	list(APPEND MODULES facebook googlephoto)
diff --git a/src/imageio/storage/flickr.c b/src/imageio/storage/flickr.c
deleted file mode 100644
index 736776a1b..000000000
--- a/src/imageio/storage/flickr.c
+++ /dev/null
@@ -1,870 +0,0 @@
-/*
-    This file is part of darktable,
-    copyright (c) 2010-2011 Jose Carlos Garcia Sogo
-
-    darktable is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    darktable is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with darktable.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "bauhaus/bauhaus.h"
-#include "common/darktable.h"
-#include "common/file_location.h"
-#include "common/image.h"
-#include "common/image_cache.h"
-#include "common/imageio.h"
-#include "common/imageio_module.h"
-#include "common/metadata.h"
-#include "common/pwstorage/pwstorage.h"
-#include "common/tags.h"
-#include "control/conf.h"
-#include "control/control.h"
-#include "dtgtk/button.h"
-#include "gui/gtk.h"
-#include "imageio/storage/imageio_storage_api.h"
-#ifdef GDK_WINDOWING_QUARTZ
-#include "osx/osx.h"
-#endif
-#include <curl/curl.h>
-#include <flickcurl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-
-DT_MODULE(1)
-
-#define API_KEY "1d25b2dfcceba8c55fecb27645c968a3"
-#define SHARED_SECRET "ac66b6c212be6f0c"
-
-typedef struct _flickr_api_context_t
-{
-  flickcurl *fc;
-
-  gboolean needsReauthentication;
-
-  /** Current album used when posting images... */
-  flickcurl_photoset *current_album;
-
-  char *album_title;
-  char *album_summary;
-  int album_public;
-  gboolean new_album;
-  gboolean error_occured;
-
-} _flickr_api_context_t;
-
-typedef struct dt_storage_flickr_gui_data_t
-{
-
-  GtkLabel *status_label;
-  GtkEntry *user_entry, *title_entry, *summary_entry;
-  GtkBox *create_box;                               // Create album options...
-  GtkWidget *permission_list, *album_list;
-
-  char *user_token;
-
-  /* List of albums */
-  flickcurl_photoset **albums;
-
-  /** Current Flickr context for the gui */
-  _flickr_api_context_t *flickr_api;
-
-} dt_storage_flickr_gui_data_t;
-
-
-typedef struct dt_storage_flickr_params_t
-{
-  int64_t hash;
-  _flickr_api_context_t *flickr_api;
-  gboolean export_tags;   // deprecated. let here not to change params size. to be removed on next version change
-  gboolean public_perm;
-  gboolean friend_perm;
-  gboolean family_perm;
-} dt_storage_flickr_params_t;
-
-
-/** Authenticates and retrieves an initialized flickr api object */
-static _flickr_api_context_t *_flickr_api_authenticate(dt_storage_flickr_gui_data_t *ui);
-
-static flickcurl_upload_status *_flickr_api_upload_photo(dt_storage_flickr_params_t *params, char *data,
-                                                         char *caption, char *description, gint imgid, uint32_t flags);
-
-static void _flickr_api_free(_flickr_api_context_t *ctx)
-{
-
-  g_free(ctx->album_title);
-  g_free(ctx->album_summary);
-
-  if(ctx->current_album != NULL) flickcurl_free_photoset(ctx->current_album);
-
-  flickcurl_free(ctx->fc);
-
-  g_free(ctx);
-}
-
-static void _flickr_api_error_handler(void *data, const char *message)
-{
-  dt_control_log(_("flickr authentication: %s"), message);
-  fprintf(stderr, "[flickr] error: %s\n", message);
-  if(data)
-  {
-    _flickr_api_context_t *ctx = (_flickr_api_context_t *)data;
-    ctx->error_occured = 1;
-  }
-}
-
-static _flickr_api_context_t *_flickr_api_authenticate(dt_storage_flickr_gui_data_t *ui)
-{
-  char *perms = NULL, *frob;
-  gchar *token;
-  char *flickr_user_token = NULL;
-  gint result;
-  _flickr_api_context_t *ctx = (_flickr_api_context_t *)g_malloc0(sizeof(_flickr_api_context_t));
-
-  flickcurl_init();
-  ctx->fc = flickcurl_new();
-  flickcurl_set_api_key(ctx->fc, API_KEY);
-  flickcurl_set_shared_secret(ctx->fc, SHARED_SECRET);
-  flickcurl_set_error_handler(ctx->fc, _flickr_api_error_handler, ctx);
-
-  if(!ui->user_token)
-  {
-    // Retrieve stored auth_key
-    // TODO: We should be able to store token for different users
-    GHashTable *table = dt_pwstorage_get("flickr");
-    gchar *_username = g_strdup(g_hash_table_lookup(table, "username"));
-    gchar *_user_token = g_strdup(g_hash_table_lookup(table, "token"));
-    g_hash_table_destroy(table);
-
-    if(_username)
-    {
-      if(!strcmp(_username, gtk_entry_get_text(ui->user_entry)))
-      {
-        flickr_user_token = g_strdup(_user_token);
-        perms = flickcurl_auth_checkToken(ctx->fc, flickr_user_token);
-      }
-      g_free(_username);
-    }
-    g_free(_user_token);
-  }
-  else
-  {
-    flickr_user_token = ui->user_token;
-    perms = flickcurl_auth_checkToken(ctx->fc, ui->user_token);
-  }
-
-
-  if(perms)
-  {
-    ui->user_token = flickr_user_token;
-    flickcurl_set_auth_token(ctx->fc, flickr_user_token);
-    return ctx;
-  }
-  else if(!ctx->error_occured)
-  {
-    frob = flickcurl_auth_getFrob(ctx->fc);
-    GError *error = NULL;
-    char *sign = g_strdup_printf("%sapi_key%sfrob%spermswrite", SHARED_SECRET, API_KEY, frob);
-    char *sign_md5 = g_compute_checksum_for_string(G_CHECKSUM_MD5, sign, strlen(sign));
-    gchar auth_url[250];
-    snprintf(auth_url, sizeof(auth_url),
-             "https://flickr.com/services/auth/?api_key=%s&perms=write&frob=%s&api_sig=%s", API_KEY, frob,
-             sign_md5);
-
-    GtkWidget *win = dt_ui_main_window(darktable.gui->ui);
-    if(!gtk_show_uri_on_window(GTK_WINDOW(win), auth_url, gtk_get_current_event_time(), &error))
-    {
-      fprintf(stderr, "[flickr] error opening browser: %s\n", error->message);
-      g_error_free(error);
-    }
-
-    g_free(sign);
-    g_free(sign_md5);
-
-    // Hold here to let the user interact
-    // Show a dialog.
-    gchar *text1, *text2;
-    text1 = g_strdup(
-        _("step 1: a new window or tab of your browser should have been loaded. you have to login into your "
-          "flickr account there and authorize darktable to upload photos before continuing."));
-    text2 = g_strdup(_("step 2: click the OK button once you are done."));
-
-    GtkWidget *window = dt_ui_main_window(darktable.gui->ui);
-    GtkWidget *flickr_auth_dialog
-        = gtk_message_dialog_new(GTK_WINDOW(window), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_INFO,
-                                 GTK_BUTTONS_OK_CANCEL, _("flickr authentication"));
-#ifdef GDK_WINDOWING_QUARTZ
-    dt_osx_disallow_fullscreen(flickr_auth_dialog);
-#endif
-    gtk_message_dialog_format_secondary_text(GTK_MESSAGE_DIALOG(flickr_auth_dialog), "%s\n\n%s", text1, text2);
-
-    result = gtk_dialog_run(GTK_DIALOG(flickr_auth_dialog));
-
-    gtk_widget_destroy(flickr_auth_dialog);
-
-    g_free(text1);
-    g_free(text2);
-
-    switch(result)
-    {
-      case GTK_RESPONSE_OK:
-        token = flickcurl_auth_getToken(ctx->fc, frob);
-        g_free(frob);
-        // TODO: Handle timeouts errors
-        if(token)
-        {
-          flickr_user_token = g_strdup(token);
-        }
-        else
-        {
-          g_free(token);
-          _flickr_api_free(ctx);
-          return NULL;
-        }
-        ui->user_token = g_strdup(flickr_user_token);
-        flickcurl_set_auth_token(ctx->fc, flickr_user_token);
-
-        /* Add creds to pwstorage */
-        GHashTable *table = g_hash_table_new(g_str_hash, g_str_equal);
-        gchar *username = (gchar *)gtk_entry_get_text(ui->user_entry);
-
-        g_hash_table_insert(table, "username", username);
-        g_hash_table_insert(table, "token", flickr_user_token);
-
-        if(!dt_pwstorage_set("flickr", table))
-        {
-          dt_print(DT_DEBUG_PWSTORAGE, "[flickr] cannot store username/token\n");
-        }
-
-        g_free(flickr_user_token);
-        g_hash_table_destroy(table);
-
-        return ctx;
-
-      default:
-        dt_print(DT_DEBUG_PWSTORAGE, "[flickr] user cancelled the login process\n");
-        return NULL;
-    }
-  }
-
-  free(perms);
-
-  return NULL;
-}
-
-
-static flickcurl_upload_status *_flickr_api_upload_photo(dt_storage_flickr_params_t *p, char *fname,
-                                                         char *caption, char *description, gint imgid, uint32_t flags)
-{
-
-  flickcurl_upload_params *params = g_malloc0(sizeof(flickcurl_upload_params));
-  flickcurl_upload_status *status;
-
-  params->safety_level = 1; // Defaults to safe photos
-  params->content_type = 1; // Defaults to photo (we don't support video!)
-
-  params->title = caption;
-  params->description = description;
-
-  if(imgid)
-  {
-    GList *tags_list = dt_tag_get_list_export(imgid, flags);
-    params->tags = dt_util_glist_to_str(",", tags_list);
-    g_list_free_full(tags_list, g_free);
-  }
-  params->photo_file = fname; // fname should be the URI of temp file
-
-  params->is_public = (int)p->public_perm;
-  params->is_friend = (int)p->friend_perm;
-  params->is_family = (int)p->family_perm;
-
-  status = flickcurl_photos_upload_params(p->flickr_api->fc, params);
-  if(!status)
-  {
-    fprintf(stderr, "[flickr] Something went wrong when uploading");
-    g_free((gchar *)params->tags);
-    g_free(params);
-    return NULL;
-  }
-  g_free((gchar *)params->tags);
-  g_free(params);
-  return status;
-}
-
-
-static char *_flickr_api_create_photoset(_flickr_api_context_t *ctx, const char *photo_id)
-{
-  char *photoset;
-  const char *title = ctx->album_title;
-  const char *summary = ctx->album_summary;
-
-  photoset = flickcurl_photosets_create(ctx->fc, title, summary, photo_id, NULL);
-  if(!photoset) fprintf(stderr, "[flickr] Something went wrong when creating gallery %s", title);
-  return photoset;
-}
-
-const char *name(const struct dt_imageio_module_storage_t *self)
-{
-  return _("flickr webalbum");
-}
-
-/** Set status connection text */
-static void set_status(dt_storage_flickr_gui_data_t *ui, gchar *message, gchar *color)
-{
-  if(!color) color = "#ffffff";
-  gchar mup[512] = { 0 };
-  snprintf(mup, sizeof(mup), "<span foreground=\"%s\" ><small>%s</small></span>", color, message);
-  gtk_label_set_markup(ui->status_label, mup);
-}
-
-static void flickr_entry_changed(GtkEntry *entry, gpointer data)
-{
-  dt_storage_flickr_gui_data_t *ui = (dt_storage_flickr_gui_data_t *)data;
-
-  if(ui->flickr_api != NULL)
-  {
-    ui->flickr_api->needsReauthentication = TRUE;
-    g_free(ui->user_token);
-    ui->user_token = NULL;
-    set_status(ui, _("not authenticated"), "#e07f7f");
-    gtk_widget_set_sensitive(GTK_WIDGET(ui->album_list), FALSE);
-  }
-}
-
-static flickcurl_photoset **_flickr_api_photosets(_flickr_api_context_t *ctx, const char *user)
-{
-  flickcurl_photoset **photoset;
-  //  char *nsid;
-
-  // TODO: Support both userid and email. As more services uses email as username
-  //      users can confuse the needed id to be introduced in the user field.
-  //  nsid = flickcurl_people_findByEmail(ctx->fc, "@");
-
-  //  no need to specify nsid at all
-  //  nsid = flickcurl_people_findByUsername(ctx->fc, user);
-
-  // "If none is specified, the calling user is assumed (or NULL) "
-  // (c) http://librdf.org/flickcurl/api/flickcurl-section-photoset.html#flickcurl-photosets-getList
-  photoset = flickcurl_photosets_getList(ctx->fc, NULL);
-
-  return photoset;
-}
-
-/** Refresh albums */
-static void refresh_albums(dt_storage_flickr_gui_data_t *ui)
-{
-  int i;
-  gtk_widget_set_sensitive(GTK_WIDGET(ui->album_list), FALSE);
-
-  if(ui->flickr_api == NULL || ui->flickr_api->needsReauthentication == TRUE)
-  {
-    if(ui->flickr_api != NULL) _flickr_api_free(ui->flickr_api);
-    ui->flickr_api = _flickr_api_authenticate(ui);
-    if(ui->flickr_api != NULL)
-    {
-      set_status(ui, _("authenticated"), "#7fe07f");
-    }
-    else
-    {
-      set_status(ui, _("not authenticated"), "#e07f7f");
-      gtk_widget_set_sensitive(GTK_WIDGET(ui->album_list), FALSE);
-      return;
-    }
-  }
-
-  // First clear the cobobox except first 2 items (none / create new album)
-  dt_bauhaus_combobox_clear(ui->album_list);
-
-  ui->albums = _flickr_api_photosets(ui->flickr_api, gtk_entry_get_text(ui->user_entry));
-  if(ui->albums)
-  {
-
-    // Add standard action
-    dt_bauhaus_combobox_add(ui->album_list, _("without album"));
-    dt_bauhaus_combobox_add(ui->album_list, _("create new album"));
-//     dt_bauhaus_combobox_add(ui->album_list, ""); // Separator // FIXME: bauhaus doesn't support separators
-
-    // Then add albums from list...
-    for(i = 0; ui->albums[i]; i++)
-    {
-      char data[512] = { 0 };
-      snprintf(data, sizeof(data), "%s (%i)", ui->albums[i]->title, ui->albums[i]->photos_count);
-      dt_bauhaus_combobox_add(ui->album_list, data);
-    }
-    dt_bauhaus_combobox_set(ui->album_list, 2);
-    gtk_widget_hide(GTK_WIDGET(ui->create_box)); // Hide create album box...
-  }
-  else
-  {
-    // Failed to parse feed of album...
-    // Lets notify somehow...
-    dt_bauhaus_combobox_set(ui->album_list, 0);
-  }
-  gtk_widget_set_sensitive(GTK_WIDGET(ui->album_list), TRUE);
-}
-
-
-static void flickr_album_changed(GtkComboBox *cb, gpointer data)
-{
-  dt_storage_flickr_gui_data_t *ui = (dt_storage_flickr_gui_data_t *)data;
-  const gchar *value = dt_bauhaus_combobox_get_text(ui->album_list);
-  if(value != NULL && strcmp(value, _("create new album")) == 0)
-  {
-    gtk_widget_set_no_show_all(GTK_WIDGET(ui->create_box), FALSE);
-    gtk_widget_show_all(GTK_WIDGET(ui->create_box));
-  }
-  else
-    gtk_widget_hide(GTK_WIDGET(ui->create_box));
-}
-
-// Refresh button pressed...
-static void flickr_button1_clicked(GtkButton *button, gpointer data)
-{
-  dt_storage_flickr_gui_data_t *ui = (dt_storage_flickr_gui_data_t *)data;
-  refresh_albums(ui);
-}
-
-/*
-static gboolean
-focus_in(GtkWidget *widget, GdkEventFocus *event, gpointer user_data)
-{
-  dt_control_tab_shortcut_off(darktable.control);
-  return FALSE;
-}
-
-static gboolean
-focus_out(GtkWidget *widget, GdkEventFocus *event, gpointer user_data)
-{
-  dt_control_tab_shortcut_on(darktable.control);
-  return FALSE;
-}
-*/
-
-void gui_init(dt_imageio_module_storage_t *self)
-{
-  self->gui_data = (dt_storage_flickr_gui_data_t *)g_malloc0(sizeof(dt_storage_flickr_gui_data_t));
-  dt_storage_flickr_gui_data_t *ui = self->gui_data;
-  self->widget = gtk_grid_new();
-  gtk_grid_set_row_spacing(GTK_GRID(self->widget), DT_PIXEL_APPLY_DPI(5));
-  gtk_grid_set_column_spacing(GTK_GRID(self->widget), DT_PIXEL_APPLY_DPI(10));
-  int line = 0;
-
-  GHashTable *table = dt_pwstorage_get("flickr");
-  gchar *_username = g_strdup(g_hash_table_lookup(table, "username"));
-  g_hash_table_destroy(table);
-
-  GtkWidget *hbox, *label, *button;
-
-
-  label = gtk_label_new(_("flickr user"));
-  g_object_set(G_OBJECT(label), "xalign", 0.0, (gchar *)0);
-  gtk_grid_attach(GTK_GRID(self->widget), label, 0, line++, 1, 1);
-
-  hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
-
-  ui->user_entry = GTK_ENTRY(gtk_entry_new());
-  gtk_widget_set_hexpand(GTK_WIDGET(ui->user_entry), TRUE);
-  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(ui->user_entry));
-  gtk_entry_set_text(ui->user_entry, _username == NULL ? "" : _username);
-  g_signal_connect(G_OBJECT(ui->user_entry), "changed", G_CALLBACK(flickr_entry_changed), (gpointer)ui);
-  gtk_entry_set_width_chars(GTK_ENTRY(ui->user_entry), 0);
-
-  button = gtk_button_new_with_label(_("login"));
-  gtk_widget_set_tooltip_text(button, _("flickr login"));
-  g_signal_connect(G_OBJECT(button), "clicked", G_CALLBACK(flickr_button1_clicked), (gpointer)ui);
-  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(ui->user_entry), TRUE, TRUE, 0);
-  gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, FALSE, 0);
-
-  gtk_grid_attach_next_to(GTK_GRID(self->widget), hbox, label, GTK_POS_RIGHT, 1, 1);
-
-
-  ui->status_label = GTK_LABEL(gtk_label_new(NULL));
-  gtk_widget_set_halign(GTK_WIDGET(ui->status_label), GTK_ALIGN_START);
-  gtk_grid_attach(GTK_GRID(self->widget), GTK_WIDGET(ui->status_label), 1, line++, 1, 1);
-
-
-  ui->permission_list = dt_bauhaus_combobox_new(NULL);
-  dt_bauhaus_widget_set_label(ui->permission_list, NULL, _("visible to"));
-  dt_bauhaus_combobox_add(ui->permission_list, _("you"));
-  dt_bauhaus_combobox_add(ui->permission_list, _("friends"));
-  dt_bauhaus_combobox_add(ui->permission_list, _("family"));
-  dt_bauhaus_combobox_add(ui->permission_list, _("friends + family"));
-  dt_bauhaus_combobox_add(ui->permission_list, _("everyone"));
-  dt_bauhaus_combobox_set(ui->permission_list, 0); // Set default permission to private
-  gtk_grid_attach(GTK_GRID(self->widget), GTK_WIDGET(ui->permission_list), 0, line++, 2, 1);
-
-
-  hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
-
-  ui->album_list = dt_bauhaus_combobox_new(NULL); // Available albums
-  dt_bauhaus_widget_set_label(ui->album_list, NULL, _("photosets"));
-  g_signal_connect(G_OBJECT(ui->album_list), "value-changed", G_CALLBACK(flickr_album_changed), (gpointer)ui);
-  gtk_widget_set_sensitive(ui->album_list, FALSE);
-  gtk_box_pack_start(GTK_BOX(hbox), ui->album_list, TRUE, TRUE, 0);
-
-  button = dtgtk_button_new(dtgtk_cairo_paint_refresh, CPF_DO_NOT_USE_BORDER, NULL);
-  gtk_widget_set_tooltip_text(button, _("refresh album list"));
-  g_signal_connect(G_OBJECT(button), "clicked", G_CALLBACK(flickr_button1_clicked), (gpointer)ui);
-  gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, FALSE, 0);
-
-  gtk_grid_attach(GTK_GRID(self->widget), hbox, 0, line++, 2, 1);
-
-
-  // the box that gets shown when a new album is to be created
-  ui->create_box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_VERTICAL, 0));
-  gtk_widget_set_no_show_all(GTK_WIDGET(ui->create_box), TRUE);
-  gtk_grid_attach(GTK_GRID(self->widget), GTK_WIDGET(ui->create_box), 0, line++, 2, 1);
-
-
-  hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
-
-  label = gtk_label_new(_("title"));
-  g_object_set(G_OBJECT(label), "xalign", 0.0, (gchar *)0);
-  gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
-
-  ui->title_entry = GTK_ENTRY(gtk_entry_new()); // Album title
-  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(ui->title_entry));
-  gtk_entry_set_text(ui->title_entry, _("my new photoset"));
-  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(ui->title_entry), TRUE, TRUE, 0);
-  gtk_entry_set_width_chars(GTK_ENTRY(ui->title_entry), 0);
-
-  gtk_box_pack_start(ui->create_box, hbox, FALSE, FALSE, 0);
-
-
-  hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
-
-  label = gtk_label_new(_("summary"));
-  g_object_set(G_OBJECT(label), "xalign", 0.0, (gchar *)0);
-  gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
-
-  ui->summary_entry = GTK_ENTRY(gtk_entry_new()); // Album summary
-  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(ui->summary_entry));
-  gtk_entry_set_text(ui->summary_entry, _("exported from darktable"));
-  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(ui->summary_entry), TRUE, TRUE, 0);
-  gtk_entry_set_width_chars(GTK_ENTRY(ui->summary_entry), 0);
-
-  gtk_box_pack_start(ui->create_box, hbox, TRUE, TRUE, 0);
-
-
-  set_status(ui, _("click login button to start"), "#ffffff");
-
-  /**
-  don't populate the combo on startup, save 3 second
-
-  // If username and password is stored, let's populate the combo
-  if( _username && _password )
-  {
-    ui->user_token = _password;
-    refresh_albums(ui);
-  }
-  */
-
-  g_free(_username);
-  dt_bauhaus_combobox_set(ui->album_list, 0);
-}
-
-void gui_cleanup(dt_imageio_module_storage_t *self)
-{
-  dt_storage_flickr_gui_data_t *ui = self->gui_data;
-  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ui->user_entry));
-  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ui->title_entry));
-  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(ui->summary_entry));
-  g_free(self->gui_data);
-}
-
-void gui_reset(dt_imageio_module_storage_t *self)
-{
-}
-
-int store(dt_imageio_module_storage_t *self, dt_imageio_module_data_t *sdata, const int imgid,
-          dt_imageio_module_format_t *format, dt_imageio_module_data_t *fdata, const int num, const int total,
-          const gboolean high_quality, const gboolean upscale, dt_colorspaces_color_profile_type_t icc_type,
-          const gchar *icc_filename, dt_iop_color_intent_t icc_intent, dt_export_metadata_t *metadata)
-{
-  gint result = 0;
-  dt_storage_flickr_params_t *p = (dt_storage_flickr_params_t *)sdata;
-  flickcurl_upload_status *photo_status;
-  gint tags = 0;
-
-  const char *ext = format->extension(fdata);
-
-  // Let's upload image...
-
-  /* construct a temporary file name */
-  char fname[PATH_MAX] = { 0 };
-  dt_loc_get_tmp_dir(fname, sizeof(fname));
-  g_strlcat(fname, "/darktable.XXXXXX.", sizeof(fname));
-  g_strlcat(fname, ext, sizeof(fname));
-
-  char *caption = NULL;
-  char *description = NULL;
-  GList *title = NULL;
-  GList *desc = NULL;
-
-  gint fd = g_mkstemp(fname);
-  fprintf(stderr, "tempfile: %s\n", fname);
-  if(fd == -1)
-  {
-    dt_control_log("failed to create temporary image for flickr export");
-    return 1;
-  }
-  close(fd);
-
-  if ((metadata->flags & DT_META_METADATA) && !(metadata->flags & DT_META_CALCULATED))
-  {
-    const dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'r');
-    // If title is not existing, then use the filename without extension. If not, then use title instead
-    title = dt_metadata_get(img->id, "Xmp.dc.title", NULL);
-    if(title != NULL)
-    {
-      caption = g_strdup(title->data);
-      g_list_free_full(title, &g_free);
-    }
-    else
-    {
-      caption = g_path_get_basename(img->filename);
-      (g_strrstr(caption, "."))[0] = '\0'; // chop extension...
-    }
-
-    desc = dt_metadata_get(img->id, "Xmp.dc.description", NULL);
-    if(desc != NULL)
-    {
-      description = desc->data;
-    }
-    dt_image_cache_read_release(darktable.image_cache, img);
-  }
-
-  if(dt_imageio_export(imgid, fname, format, fdata, high_quality, upscale, TRUE, icc_type, icc_filename, icc_intent,
-                       self, sdata, num, total, metadata) != 0)
-  {
-    fprintf(stderr, "[imageio_storage_flickr] could not export to file: `%s'!\n", fname);
-    dt_control_log(_("could not export to file `%s'!"), fname);
-    result = 1;
-    goto cleanup;
-  }
-
-#ifdef _OPENMP
-#pragma omp critical
-#endif
-  {
-    // TODO: Check if this could be done in threads, so we enhance export time by using
-    //      upload time for one image to export another image to disk.
-    // Upload image
-    // Do we export tags?
-    if(metadata->flags & DT_META_TAG) tags = imgid;
-    photo_status = _flickr_api_upload_photo(p, fname, caption, description, tags, metadata->flags);
-  }
-
-  if(!photo_status)
-  {
-    fprintf(stderr, "[imageio_storage_flickr] could not upload to flickr!\n");
-    dt_control_log(_("could not upload to flickr!"));
-    result = 1;
-    goto cleanup;
-  }
-
-  //  int fail = 0;
-  // A photoset is only created if we have an album title set
-  if(p->flickr_api->current_album == NULL && p->flickr_api->new_album == TRUE)
-  {
-    char *photoset_id;
-    photoset_id = _flickr_api_create_photoset(p->flickr_api, photo_status->photoid);
-
-    if(photoset_id == NULL)
-    {
-      dt_control_log("failed to create flickr album");
-      //      fail = 1;
-    }
-    else
-    {
-      //      p->flickr_api->new_album = FALSE;
-      p->flickr_api->current_album = flickcurl_photosets_getInfo(p->flickr_api->fc, photoset_id);
-    }
-  }
-
-  //  if(fail) return 1;
-  // TODO: What to do if photoset creation fails?
-
-  // Add to gallery, if needed
-  if(p->flickr_api->current_album != NULL && p->flickr_api->new_album != TRUE)
-  {
-    flickcurl_photosets_addPhoto(p->flickr_api->fc, p->flickr_api->current_album->id, photo_status->photoid);
-    // TODO: Check for errors adding photo to gallery
-  }
-  else
-  {
-    if(p->flickr_api->current_album != NULL && p->flickr_api->new_album == TRUE)
-    {
-      p->flickr_api->new_album = FALSE;
-    }
-  }
-
-cleanup:
-
-  // And remove from filesystem..
-  g_unlink(fname);
-  g_free(caption);
-  if(desc) g_list_free_full(desc, &g_free);
-
-  if(!result)
-  {
-    // this makes sense only if the export was successful
-    dt_control_log(ngettext("%d/%d exported to flickr webalbum", "%d/%d exported to flickr webalbum", num),
-                   num, total);
-  }
-  return result;
-}
-
-size_t params_size(dt_imageio_module_storage_t *self)
-{
-  return sizeof(int64_t);
-}
-
-void init(dt_imageio_module_storage_t *self)
-{
-}
-
-void *get_params(dt_imageio_module_storage_t *self)
-{
-  // have to return the size of the struct to store (i.e. without all the variable pointers at the end)
-  // TODO: if a hash to encrypted data is stored here, return only this size and store it at the beginning of
-  // the struct!
-  dt_storage_flickr_gui_data_t *ui = (dt_storage_flickr_gui_data_t *)self->gui_data;
-  if(!ui) return NULL; // gui not initialized, CLI mode
-  dt_storage_flickr_params_t *d = (dt_storage_flickr_params_t *)g_malloc0(sizeof(dt_storage_flickr_params_t));
-  if(!d) return NULL;
-  d->hash = 1;
-
-  // fill d from controls in ui
-  if(ui->flickr_api && ui->flickr_api->needsReauthentication == FALSE)
-  {
-    // We are authenticated and off to actually export images..
-    d->flickr_api = ui->flickr_api;
-    int index = dt_bauhaus_combobox_get(ui->album_list);
-    if(index >= 0)
-    {
-      switch(index)
-      {
-        case 0: // No album
-          d->flickr_api->current_album = NULL;
-          break;
-        case 1: // Create new album
-          d->flickr_api->current_album = NULL;
-          d->flickr_api->album_title = g_strdup(gtk_entry_get_text(ui->title_entry));
-          d->flickr_api->album_summary = g_strdup(gtk_entry_get_text(ui->summary_entry));
-          d->flickr_api->new_album = TRUE;
-          break;
-        default:
-          // use existing album
-          d->flickr_api->current_album
-              = flickcurl_photosets_getInfo(d->flickr_api->fc, ui->albums[index - 2]->id);
-          if(d->flickr_api->current_album == NULL)
-          {
-            // Something went wrong...
-            fprintf(stderr, "Something went wrong.. album index %d = NULL\n", index - 2);
-            g_free(d);
-            return NULL;
-          }
-          break;
-      }
-    }
-    else
-    {
-      g_free(d);
-      return NULL;
-    }
-
-    /* Handle the permissions */
-    int perm_index = (int)dt_bauhaus_combobox_get(ui->permission_list);
-    switch(perm_index)
-    {
-      case 0: // Private
-        d->public_perm = 0;
-        d->friend_perm = 0;
-        d->family_perm = 0;
-        break;
-      case 1: // Friends
-        d->public_perm = 0;
-        d->friend_perm = 1;
-        d->family_perm = 0;
-        break;
-      case 2: // Family
-        d->public_perm = 0;
-        d->friend_perm = 0;
-        d->family_perm = 1;
-        break;
-      case 3: // Friend + Family
-        d->public_perm = 0;
-        d->friend_perm = 1;
-        d->family_perm = 1;
-        break;
-      case 4: // Public
-        d->public_perm = 1;
-        d->friend_perm = 0;
-        d->family_perm = 0;
-        break;
-    }
-
-    // Let UI forget about this api context and recreate a new one for further usage...
-    ui->flickr_api = _flickr_api_authenticate(ui);
-    if(ui->flickr_api)
-    {
-      set_status(ui, _("authenticated"), "#7fe07f");
-    }
-    else
-    {
-      set_status(ui, _("not authenticated"), "#e07f7f");
-      gtk_widget_set_sensitive(GTK_WIDGET(ui->album_list), FALSE);
-    }
-  }
-  else
-  {
-    set_status(ui, _("not authenticated"), "#e07f7f");
-    gtk_widget_set_sensitive(GTK_WIDGET(ui->album_list), FALSE);
-    g_free(d);
-    return NULL;
-  }
-  return d;
-}
-
-int set_params(dt_imageio_module_storage_t *self, const void *params, const int size)
-{
-  if(size != self->params_size(self)) return 1;
-  // gui stuff not updated, as sensitive user data is not stored in the preset.
-  // TODO: store name/hash in kwallet/etc module and get encrypted stuff from there!
-  return 0;
-}
-
-int supported(dt_imageio_module_storage_t *storage, dt_imageio_module_format_t *format)
-{
-  if(strcmp(format->mime(NULL), "image/jpeg") == 0)
-    return 1;
-  else if(strcmp(format->mime(NULL), "image/png") == 0)
-    return 1;
-
-  return 0;
-}
-
-void free_params(dt_imageio_module_storage_t *self, dt_imageio_module_data_t *params)
-{
-  if(!params) return;
-
-  dt_storage_flickr_params_t *d = (dt_storage_flickr_params_t *)params;
-
-  _flickr_api_free(d->flickr_api); // TODO
-
-  free(params);
-}
-
-// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh
-// vim: shiftwidth=2 expandtab tabstop=2 cindent
-// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;
diff --git a/src/libs/history.c b/src/libs/history.c
index 3962c1744..96b17d623 100644
--- a/src/libs/history.c
+++ b/src/libs/history.c
@@ -47,11 +47,15 @@ typedef struct dt_lib_history_t
   GtkWidget *create_button;
 //   GtkWidget *apply_button;
   GtkWidget *compress_button;
+  GtkWidget *ktx_delete_button;
+  GtkWidget *ktx_deletesel_button;
   gboolean record_undo;
 } dt_lib_history_t;
 
 /* compress history stack */
 static void _lib_history_compress_clicked_callback(GtkWidget *widget, gpointer user_data);
+static void _lib_history_ktx_delete_clicked_callback(GtkWidget *widget, gpointer user_data);
+static void _lib_history_ktx_deletesel_clicked_callback(GtkWidget *widget, gpointer user_data);
 static void _lib_history_button_clicked_callback(GtkWidget *widget, gpointer user_data);
 static void _lib_history_create_style_button_clicked_callback(GtkWidget *widget, gpointer user_data);
 /* signal callback for history change */
@@ -110,11 +114,21 @@ void gui_init(dt_lib_module_t *self)
 
   GtkWidget *hhbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
 
-  d->compress_button = gtk_button_new_with_label(_("compress history stack"));
+  d->compress_button = gtk_button_new_with_label(_("compress"));
   gtk_label_set_xalign (GTK_LABEL(gtk_bin_get_child(GTK_BIN(d->compress_button))), 0.0f);
   gtk_widget_set_tooltip_text(d->compress_button, _("create a minimal history stack which produces the same image"));
   g_signal_connect(G_OBJECT(d->compress_button), "clicked", G_CALLBACK(_lib_history_compress_clicked_callback), NULL);
 
+  d->ktx_deletesel_button = gtk_button_new_with_label(_("delete"));
+  gtk_label_set_xalign (GTK_LABEL(gtk_bin_get_child(GTK_BIN(d->ktx_deletesel_button))), 0.0f);
+  gtk_widget_set_tooltip_text(d->ktx_deletesel_button, _("delete selected module"));
+  g_signal_connect(G_OBJECT(d->ktx_deletesel_button), "clicked", G_CALLBACK(_lib_history_ktx_deletesel_clicked_callback), NULL);
+
+  d->ktx_delete_button = gtk_button_new_with_label(_("reset"));
+  gtk_label_set_xalign (GTK_LABEL(gtk_bin_get_child(GTK_BIN(d->ktx_delete_button))), 0.0f);
+  gtk_widget_set_tooltip_text(d->ktx_delete_button, _("delete history stack"));
+  g_signal_connect(G_OBJECT(d->ktx_delete_button), "clicked", G_CALLBACK(_lib_history_ktx_delete_clicked_callback), NULL);
+
   /* add toolbar button for creating style */
   d->create_button = dtgtk_button_new(dtgtk_cairo_paint_styles, CPF_DO_NOT_USE_BORDER, NULL);
   g_signal_connect(G_OBJECT(d->create_button), "clicked",
@@ -123,6 +137,8 @@ void gui_init(dt_lib_module_t *self)
 
   /* add buttons to buttonbox */
   gtk_box_pack_start(GTK_BOX(hhbox), d->compress_button, TRUE, TRUE, 0);
+  gtk_box_pack_start(GTK_BOX(hhbox), d->ktx_delete_button, TRUE, TRUE, 0);
+  gtk_box_pack_start(GTK_BOX(hhbox), d->ktx_deletesel_button, TRUE, TRUE, 0);
   gtk_box_pack_start(GTK_BOX(hhbox), d->create_button, FALSE, FALSE, 0);
 
   /* add history list and buttonbox to widget */
@@ -741,6 +757,87 @@ static void _lib_history_compress_clicked_callback(GtkWidget *widget, gpointer u
   dt_dev_modulegroups_set(darktable.develop, dt_dev_modulegroups_get(darktable.develop));
 }
 
+static void _lib_history_ktx_delete_clicked_callback(GtkWidget *widget, gpointer user_data)
+{
+  const int imgid = darktable.develop->image_storage.id;
+  if(!imgid) return;
+  // make sure the right history is in there:
+  dt_dev_write_history(darktable.develop);
+  sqlite3_stmt *stmt;
+
+  // remove all modules
+  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), "DELETE FROM main.history WHERE imgid = ?1", -1, &stmt, NULL);
+  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);
+  sqlite3_step(stmt);
+  sqlite3_finalize(stmt);
+
+  // load new history and write it back to ensure that all history are properly numbered without a gap
+  dt_dev_reload_history_items(darktable.develop);
+  dt_dev_write_history(darktable.develop);
+
+  // then we can get the item to select in the new clean-up history retrieve the position of the module
+  // corresponding to the history end.
+  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), "SELECT IFNULL(MAX(num)+1, 0) FROM main.history "
+                                                             "WHERE imgid=?1", -1, &stmt, NULL);
+  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);
+
+  if (sqlite3_step(stmt) == SQLITE_ROW)
+    darktable.develop->history_end = sqlite3_column_int(stmt, 0);
+  sqlite3_finalize(stmt);
+
+  // select the new history end corresponding to the one before the history compression
+  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), "UPDATE main.images SET history_end=?2 WHERE id=?1",
+                              -1, &stmt, NULL);
+  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);
+  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, darktable.develop->history_end);
+  sqlite3_step(stmt);
+  sqlite3_finalize(stmt);
+
+  dt_dev_reload_history_items(darktable.develop);
+  dt_dev_modulegroups_set(darktable.develop, dt_dev_modulegroups_get(darktable.develop));
+}
+
+static void _lib_history_ktx_deletesel_clicked_callback(GtkWidget *widget, gpointer user_data)
+{
+  const int imgid = darktable.develop->image_storage.id;
+  if(!imgid) return;
+  // make sure the right history is in there:
+  dt_dev_write_history(darktable.develop);
+  sqlite3_stmt *stmt;
+
+  // remove all modules
+  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), "DELETE FROM main.history WHERE imgid = ?1 AND num = ?2", -1, &stmt, NULL);
+  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);
+  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, darktable.develop->history_end - 1);
+  sqlite3_step(stmt);
+  sqlite3_finalize(stmt);
+
+  // load new history and write it back to ensure that all history are properly numbered without a gap
+  dt_dev_reload_history_items(darktable.develop);
+  dt_dev_write_history(darktable.develop);
+
+  // then we can get the item to select in the new clean-up history retrieve the position of the module
+  // corresponding to the history end.
+  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), "SELECT IFNULL(MAX(num)+1, 0) FROM main.history "
+                                                             "WHERE imgid=?1", -1, &stmt, NULL);
+  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);
+
+  if (sqlite3_step(stmt) == SQLITE_ROW)
+    darktable.develop->history_end = sqlite3_column_int(stmt, 0);
+  sqlite3_finalize(stmt);
+
+  // select the new history end corresponding to the one before the history compression
+  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), "UPDATE main.images SET history_end=?2 WHERE id=?1",
+                              -1, &stmt, NULL);
+  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);
+  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, darktable.develop->history_end);
+  sqlite3_step(stmt);
+  sqlite3_finalize(stmt);
+
+  dt_dev_reload_history_items(darktable.develop);
+  dt_dev_modulegroups_set(darktable.develop, dt_dev_modulegroups_get(darktable.develop));
+}
+
 static void _lib_history_button_clicked_callback(GtkWidget *widget, gpointer user_data)
 {
   static int reset = 0;
diff --git a/src/libs/modulegroups.c b/src/libs/modulegroups.c
index f70a8b614..173cc3feb 100644
--- a/src/libs/modulegroups.c
+++ b/src/libs/modulegroups.c
@@ -216,6 +216,15 @@ void gui_init(dt_lib_module_t *self)
   g_signal_connect(d->buttons[g_index], "toggled", G_CALLBACK(_lib_modulegroups_toggle), self);
   gtk_widget_set_tooltip_text(d->buttons[g_index], _("effects group"));
 
+  /* all */
+  d->buttons[DT_MODULEGROUP_ALL] = dtgtk_togglebutton_new(dtgtk_cairo_paint_modulegroup_all, pf, NULL);
+  g_signal_connect(d->buttons[DT_MODULEGROUP_ALL], "toggled", G_CALLBACK(_lib_modulegroups_toggle),
+                   self);
+  gtk_widget_set_tooltip_text(d->buttons[DT_MODULEGROUP_ALL], _("all enabled modules"));
+
+  /* minimize table height before adding the buttons */
+  gtk_widget_set_size_request(self->widget, -1, -1);
+
   /*
    * layout button row
    */
@@ -319,6 +328,8 @@ static gboolean _lib_modulegroups_test_internal(dt_lib_module_t *self, uint32_t
     return TRUE;
   else if(iop_group & IOP_GROUP_EFFECT && group == DT_MODULEGROUP_EFFECT)
     return TRUE;
+  else if(iop_group & IOP_GROUP_ALL && group == DT_MODULEGROUP_ALL)
+    return TRUE;
   return FALSE;
 }
 
diff --git a/src/libs/modulegroups.h b/src/libs/modulegroups.h
index 5c3052f3a..8975baf04 100644
--- a/src/libs/modulegroups.h
+++ b/src/libs/modulegroups.h
@@ -31,6 +31,7 @@ typedef enum dt_lib_modulegroup_t
   DT_MODULEGROUP_COLOR,
   DT_MODULEGROUP_CORRECT,
   DT_MODULEGROUP_EFFECT,
+  DT_MODULEGROUP_ALL,
 
   /* don't touch the following */
   DT_MODULEGROUP_SIZE,
diff --git a/src/views/view.c b/src/views/view.c
index 55b803a63..535e74033 100644
--- a/src/views/view.c
+++ b/src/views/view.c
@@ -797,12 +797,18 @@ int dt_view_process_image_over(dt_view_image_over_t what, int active, cairo_t *c
 {
   int ret = 0; // return value
 
-  // we need to squeeze 5 stars + 2 symbols on a thumbnail width
-  // each of them having a width of 2 * r1 and spaced by r1
-  // that's 14 * r1 of content + 6 * r1 of spacing
-  // inner margins are 0.045 * width
-  const float r1 = fminf(DT_PIXEL_APPLY_DPI(20.0f) / 2.0f, 0.91 * width / 20.0f);
-  const float r2 = r1 / 2.5f;
+  float fscale = DT_PIXEL_APPLY_DPI(fminf(width, height));
+  float r1, r2;
+  if(zoom != 1)
+  {
+    r1 = 0.05 * width * 0.7;
+    r2 = 0.022 * width * 0.7;
+  }
+  else
+  {
+    r1 = 0.015 * fscale;
+    r2 = 0.007 * fscale;
+  }
 
   if(cr)
   {
@@ -843,7 +849,7 @@ int dt_view_process_image_over(dt_view_image_over_t what, int active, cairo_t *c
     case DT_VIEW_STAR_4:
     case DT_VIEW_STAR_5:
       if(zoom != 1)
-        x = 0.5f * width - 5.0f * r1 + (what - DT_VIEW_STAR_1) * 2.5f * r1;
+        x = (0.26 + (what - DT_VIEW_STAR_1) * 0.12) * width * 0.7;
       else
         x = 3.0f * r1 + (what - DT_VIEW_STAR_1 + 1.5f) * 2.5f * r1;
 
@@ -1177,22 +1183,17 @@ int dt_view_image_expose(dt_view_image_expose_t *vals)
       cairo_stroke(cr);
     }
 
-    if(img)
+/*    if(img)
     {
       PangoLayout *layout;
-      PangoRectangle ink;
+      const int exif_offset = DT_PIXEL_APPLY_DPI(3);
+      layout = pango_cairo_create_layout(cr);
       PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus->pango_font_desc);
       pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);
-      const int fontsize = fminf(DT_PIXEL_APPLY_DPI(20.0), .09 * width);
+      const int fontsize = 0.07 * width;
       pango_font_description_set_absolute_size(desc, fontsize * PANGO_SCALE);
-      layout = pango_cairo_create_layout(cr);
       pango_layout_set_font_description(layout, desc);
-      const char *ext = img->filename + strlen(img->filename);
-      while(ext > img->filename && *ext != '.') ext--;
-      ext++;
-      dt_gui_gtk_set_source_rgb(cr, fontcol);
-
-      char* upcase_ext = g_ascii_strup(ext, -1);  // extension in capital letters to avoid character descenders
+      dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_THUMBNAIL_BORDER);
 
       if(buf_ht > buf_wd)
       {
@@ -1203,27 +1204,9 @@ int dt_view_image_expose(dt_view_image_expose_t *vals)
           pango_layout_get_pixel_extents(layout, &ink, NULL);
           max_chr_width = MAX(max_chr_width, ink.width);
         }
-
-        for (int i = 0, yoffs = fontsize;  upcase_ext[i] != 0; i++,  yoffs -= fontsize)
-        {
-          pango_layout_set_text(layout, &upcase_ext[i], 1);
-          pango_layout_get_pixel_extents(layout, &ink, NULL);
-          cairo_move_to(cr, .045 * width - ink.x + (max_chr_width - ink.width) / 2, .045 * height - yoffs + fontsize);
-          pango_cairo_show_layout(cr, layout);
-        }
-      }
-      else
-      {
-        pango_layout_set_text(layout, upcase_ext, -1);
-        pango_layout_get_pixel_extents(layout, &ink, NULL);
-        cairo_move_to(cr, .045 * width - ink.x, .045 * height);
-        pango_cairo_show_layout(cr, layout);
-      }
-      g_free(upcase_ext);
       pango_font_description_free(desc);
       g_object_unref(layout);
-
-    }
+    } */
   }
 
   // if we got a different mip than requested, and it's not a skull (8x8 px), we count
@@ -1337,7 +1320,10 @@ int dt_view_image_expose(dt_view_image_expose_t *vals)
         scale = fminf((width - 2 * tb) / (float)buf_wd, (height - 2 * tb) / (float)buf_ht) * fz;
       }
       else
-        scale = fminf(width * imgwd / (float)buf_wd, height * imgwd / (float)buf_ht) * fz;
+        if (buf_ht < buf_wd)
+          scale = fminf(width * imgwd / (float)buf_wd, height * imgwd / (float)buf_ht) * fz;
+        else
+          scale = fminf(width * imgwd / (float)buf_wd, height * imgwd / (float)buf_ht) / 1.5 * fz;
     }
     // draw centered and fitted:
     cairo_save(cr);
@@ -1345,7 +1331,10 @@ int dt_view_image_expose(dt_view_image_expose_t *vals)
     if (image_only) // in this case we want to display the picture exactly at (px, py)
       cairo_translate(cr, px, py);
     else
-      cairo_translate(cr, width / 2.0, height / 2.0);
+      if (zoom == 1)
+        cairo_translate(cr, width / 2.0, height / 2.0);
+      else
+        cairo_translate(cr, width / 2.0, height / 3.0);
 
     cairo_scale(cr, scale, scale);
 
@@ -1490,6 +1479,7 @@ int dt_view_image_expose(dt_view_image_expose_t *vals)
 
   cairo_save(cr);
 
+  const float fscale = DT_PIXEL_APPLY_DPI(fminf(width, height));
   if(vals->mouse_over || full_preview || darktable.gui->show_overlays || zoom == 1)
   {
     if(draw_metadata && width > DECORATION_SIZE_LIMIT)
@@ -1498,7 +1488,7 @@ int dt_view_image_expose(dt_view_image_expose_t *vals)
       cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1));
       dt_gui_gtk_set_source_rgb(cr, outlinecol);
       cairo_set_line_join(cr, CAIRO_LINE_JOIN_ROUND);
-
+      const gboolean ktx_show_on_all = dt_conf_get_bool("ktx/show_exif_on_all_thumbs");
       const gboolean extended_thumb_overlay = dt_conf_get_bool("plugins/lighttable/extended_thumb_overlay");
       const gboolean image_is_rejected = (img && ((img->flags & 0x7) == 6));
 
@@ -1507,41 +1497,65 @@ int dt_view_image_expose(dt_view_image_expose_t *vals)
 
       if(img)
       {
-        if(zoom != 1 && (!darktable.gui->show_overlays || vals->mouse_over) && extended_thumb_overlay)
+//      if(zoom != 1 && (!darktable.gui->show_overlays || vals->mouse_over) && extended_thumb_overlay)
+        if (zoom != 1 && extended_thumb_overlay && (!darktable.gui->show_overlays || ktx_show_on_all))
         {
-          // size of stars overlays
-          const double r1 = MIN(DT_PIXEL_APPLY_DPI(20.0), 0.91 * width / 10.0);
-          const double fontsize = MIN(DT_PIXEL_APPLY_DPI(16.0), 0.67 * 0.91 * width / 10.0);
-          const double exif_offset = 0.045 * width;
-          const double line_offs = 1.25 * fontsize;
-          const double overlay_height = 2 * exif_offset + r1 + 1.75 * line_offs;
-
-          const double x0 = 0;
-          const double y0 = height - overlay_height;
-          const double rect_width = width;
-          const double rect_height = overlay_height;
-
+          const double overlay_height = 0.33 * height;
+          const int exif_offset = DT_PIXEL_APPLY_DPI(3);
+          const int fontsize = 0.18 * overlay_height;
+          const double line_offs = 1.15 * fontsize;
+
+
+          double x0 = DT_PIXEL_APPLY_DPI(1);
+          double y0 = height - overlay_height;
+          double rect_width = width - DT_PIXEL_APPLY_DPI(2);
+          double rect_height = overlay_height - DT_PIXEL_APPLY_DPI(2);
+          double radius = DT_PIXEL_APPLY_DPI(5);
+          double x1, y1, off, off1;
+
+          x1 = x0 + rect_width;
+          y1 = y0 + rect_height;
+          off = radius * 0.666;
+          off1 = radius - off;
           cairo_save(cr);
-          cairo_rectangle(cr, x0, y0, rect_width, rect_height);
-          dt_gui_gtk_set_source_rgb(cr, bgcol);
-          cairo_fill(cr);
+          cairo_move_to(cr, x0, y0 + radius);
+          cairo_curve_to(cr, x0, y0 + off1, x0 + off1, y0, x0 + radius, y0);
+          cairo_line_to(cr, x1 - radius, y0);
+          cairo_curve_to(cr, x1 - off1, y0, x1, y0 + off1, x1, y0 + radius);
+          cairo_line_to(cr, x1, y1 - radius);
+          cairo_curve_to(cr, x1, y1 - off1, x1 - off1, y1, x1 - radius, y1);
+          cairo_line_to(cr, x0 + radius, y1);
+          cairo_curve_to(cr, x0 + off1, y1, x0, y1 - off1, x0, y1 - radius);
+          cairo_close_path(cr);
+          dt_gui_gtk_set_source_rgba(cr, DT_GUI_COLOR_KTX_1, 1.0);
+          cairo_fill_preserve(cr);
+          cairo_set_line_width(cr, 0.005 * width);
+          dt_gui_gtk_set_source_rgb(cr, outlinecol);
+          cairo_stroke(cr);
 
           // some exif data
           PangoLayout *layout;
           PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus->pango_font_desc);
-          pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);
+          pango_font_description_set_weight(desc, PANGO_WEIGHT_SEMIBOLD);
           layout = pango_cairo_create_layout(cr);
           pango_font_description_set_absolute_size(desc, fontsize * PANGO_SCALE);
           pango_layout_set_font_description(layout, desc);
-          dt_gui_gtk_set_source_rgb(cr, outlinecol);
+          dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_THUMBNAIL_FONT);
 
           cairo_move_to(cr, x0 + exif_offset, y0 + exif_offset / 2.0);
           pango_layout_set_ellipsize(layout, PANGO_ELLIPSIZE_MIDDLE);
           pango_layout_set_width(layout, (int)(PANGO_SCALE * (width - 2 * exif_offset)));
           pango_layout_set_text(layout, img->filename, -1);
           pango_cairo_show_layout(cr, layout);
+
+          cairo_move_to(cr, x0 + exif_offset, y0 + exif_offset + line_offs);
+          pango_layout_set_ellipsize(layout, PANGO_ELLIPSIZE_MIDDLE);
+          pango_layout_set_width(layout, (int)(PANGO_SCALE * (width - 2 * exif_offset)));
+          pango_layout_set_text(layout, img->exif_datetime_taken, -1);
+          pango_cairo_show_layout(cr, layout);
+
           char exifline[50];
-          cairo_move_to(cr, x0 + exif_offset, y0 + exif_offset / 2.0 + line_offs);
+          cairo_move_to(cr, x0 + exif_offset, y0 + exif_offset + line_offs*2);
           dt_image_print_exif(img, exifline, sizeof(exifline));
           pango_layout_set_ellipsize(layout, PANGO_ELLIPSIZE_END);
           pango_layout_set_text(layout, exifline, -1);
@@ -1710,22 +1724,26 @@ int dt_view_image_expose(dt_view_image_expose_t *vals)
     PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus->pango_font_desc);
     pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);
     layout = pango_cairo_create_layout(cr);
-    pango_font_description_set_absolute_size(desc, z1_fontsize * PANGO_SCALE);
+    const int fontsize = 0.015 * fscale;
+    pango_font_description_set_absolute_size(desc, fontsize * PANGO_SCALE);
     pango_layout_set_font_description(layout, desc);
     cairo_set_line_join(cr, CAIRO_LINE_JOIN_ROUND);
     cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(2.0));
-    cairo_set_source_rgb(cr, 0.3, 0.3, 0.3);
+    cairo_set_source_rgb(cr, 0.0, 0.0, 0.0);
 
-    cairo_move_to(cr, z1_fontsize, z1_fontsize);
+    cairo_move_to(cr, .02 * fscale, .02 * fscale - fontsize);
     pango_layout_set_text(layout, img->filename, -1);
     pango_cairo_layout_path(cr, layout);
+    cairo_move_to(cr, .02 * fscale, .04 * fscale - fontsize);
+    pango_layout_set_text(layout, img->exif_datetime_taken, -1);
+    pango_cairo_layout_path(cr, layout);
     char exifline[50];
-    cairo_move_to(cr, z1_fontsize, 2.25f * z1_fontsize);
+    cairo_move_to(cr, .02 * fscale, .06 * fscale - fontsize);
     dt_image_print_exif(img, exifline, sizeof(exifline));
     pango_layout_set_text(layout, exifline, -1);
     pango_cairo_layout_path(cr, layout);
     cairo_stroke_preserve(cr);
-    cairo_set_source_rgb(cr, .7, .7, .7);
+    cairo_set_source_rgb(cr, 1.0, 1.0, 1.0);
     cairo_fill(cr);
     pango_font_description_free(desc);
     g_object_unref(layout);
